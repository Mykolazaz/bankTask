---
title: "Data Manipulation Task"
output: pdf_document
date: "`r Sys.Date()`"
---

## Packages

```{r message=FALSE, warning=FALSE}
library(readr)
library(dplyr)
library(DescTools)
```

## Importing data

```{r message=FALSE, warning=FALSE}
bank_full <- read_delim("bankData/bank-full.csv", 
    delim = ";", escape_double = FALSE, trim_ws = TRUE)
```

## Data cleaning

```{r}
head(bank_full)
```

```{r}
tail(bank_full)
```

A first look at the data shows us that many of the provided columns have an incorrect data type. For example, default and marital status are set as character data types when they should be factors.

```{r}
str(bank_full)
```

A look at the description by the researchers tells us that there are no missing values even though some columns have values "unknown". We have to decide whether to keep them as "unknown" or convert them to NA. As the data given to a logistic regression model cannot have missing entries, "unknown" values will be kept.

```{r}
bank_full <- bank_full %>%
  mutate(job = if_else(job == "admin.", "admin", job)) %>% 
  mutate(across(c(marital, job, education, contact, poutcome), as.factor)) %>% 
  mutate(across(c(default, housing, loan, y), ~ .x == "yes")) %>% 
  mutate(month = factor(month, levels = c("jan", "feb", "mar", "apr", "may", "jun",
                                          "jul", "aug", "sep", "oct", "nov", "dec")))

str(bank_full)
```

Lastly, since some columns have names that may be difficult to interpret without looking at the metadata first, we should rename them.

```{r}
bank_full <- bank_full %>% 
  rename(in_default = "default",
         housing_loan = "housing",
         personal_loan = "loan",
         contact_type = "contact",
         subscribed = "y")
```

```{r}
lapply(bank_full[ , !(names(bank_full) %in% c("age", "balance", "duration", "pdays"))], unique)
```

Data is now cleaned, we now may move to the next step.

## Manipulating data

We select a small random sample of the provided data with a pre-determined seed for repeatable results.

```{r}
set.seed(167)
smallBank <- sample_n(bank_full, 400, replace = FALSE)
```

```{r}
summary(bank_full[, c("age", "job", "marital", "education", "in_default", "housing_loan", "personal_loan", "poutcome")])
```
We notice that practically all values in poutcome are set as unknown and therefore won't be useful during modelling. We can remove that column.

```{r}
bank_full <- bank_full %>% 
  select(-poutcome)
```

Let's choose a data frame with the clients that have a dangerously low balance and have or have had a partner at a point in their life. Due to low numbers in the total population, let's search for them in the full data set.

```{r}
lowBalwPartner <- bank_full %>% 
  filter(balance < 100 & marital %in% c("maried", "divorced"))
```

Also, we'll filter another group of clients which have at least one loan with the bank and are at least of the median age for the data set.

```{r}
withLoans <- bank_full %>% 
  filter((housing_loan == TRUE | personal_loan == TRUE) & age >= median(age, na.rm = TRUE))
```

We may also calculate the summarizing statistics.

```{r}
job_summary <- bank_full %>%
  group_by(job) %>%
  summarise(
    age_mean = round(mean(age, na.rm = TRUE), 2),
    balance_mean = mean(balance, na.rm = TRUE),
    balance_median = median(balance, na.rm = TRUE),
    balance_sd = sd(balance, na.rm = TRUE),
    duration_median = median(duration, na.rm = TRUE),
    n = n()
  ) %>%
  arrange(desc(n), desc(age_mean))

print(job_summary)
```

The summarized statistics allows us to make a few insights about the clients that were contacted. First, the clients with a job in management had the highest average balance. Second, high standard deviation tells us that client balance varies quite a lot from one client to another. Third, most clients over all had a balance in the mid-500s. Fourth, most of the contacted clients were blue-collar workers. That is quite normal as blue-collar workers usually make up the largest percentage of the population.

We should also inspect the clients that chose to subscribe to a deposit and what characteristics they show.

```{r}
subscriber_summary <- bank_full %>%
  filter(subscribed == TRUE) %>%
  select(-in_default) %>%
  summarise(across(everything(), ~DescTools::Mode(.x), .names = "mode_{.col}"))

print(subscriber_summary)
```

The data shows us that the "most common" client that chose to subscribe to a deposit is a 32 y.o. married management worker which was contacted via phone in May and the phone call lasted 261 seconds. These could be the key factors which influence the probability of subscription.

Using the previous conclusion, we may create a mock variable that assigns a score of how likely each client is to subscribe to a deposit. In order to give sense to the number representation of the score, we will apply a min-max transformation.

```{r}
find_engagement <- function(duration, balance, housing_loan, personal_loan, in_default) {
  if(in_default != TRUE){
    score <- duration + 10 * (balance / 1000) - housing_loan * 10 - personal_loan * 20
    if (score < 0){
      return(0)
    } else {
      return(score)
    }
  } else {
    return(0)
  }
}

bank_full <- bank_full %>% 
  mutate(engagement_score = mapply(find_engagement, duration, balance, housing_loan, personal_loan, in_default)) %>%
  mutate(engagement_score = round((engagement_score - min(engagement_score, na.rm = TRUE)) / 
           (max(engagement_score, na.rm = TRUE) - min(engagement_score, na.rm = TRUE)), 3))
```

In order to detect clients that have no loans and sufficient balance to make a bank term deposit (a. k. a. are "good" potential depositors), but have specifically chosen not to, we will create a new indicator column.

```{r}
bank_full_potencial <- bank_full %>%
  mutate(potential_client = balance > 1000 & campaign > 0 & previous == 0 &
                            !in_default & !housing_loan & !personal_loan)
summary(bank_full_potencial$potential_client)
```

We can see that to 5227 "potential" clients the marketing campaign hasn't been effective.

We can also take a look at the contacted clients with the highest balance by job type.

```{r}
max_balance_job <- bank_full %>% 
  group_by(job) %>% 
  summarise(max_balance = max(balance))

print(max_balance_job)
```

The client with the highest balance has a job in management.
