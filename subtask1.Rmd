---
title: "Data Manipulation Task"
output: pdf_document
date: "`r Sys.Date()`"
---

## Packages

```{r message=FALSE, warning=FALSE}
library(readr)
library(dplyr)
library(DescTools)
library(gmodels)
```

## Importing data

```{r message=FALSE, warning=FALSE}
bank_full <- read_delim("bankData/bank-full.csv", 
    delim = ";", escape_double = FALSE, trim_ws = TRUE)
```

## Data cleaning

```{r}
head(bank_full)
```

```{r}
tail(bank_full)
```

```{r}
str(bank_full)
```

A first look at the data shows us that many of the provided columns have an incorrect data type. For example, default and marital status are set as character data types when they should be factors.

```{r}
bank_full <- bank_full %>%
  mutate(job = if_else(job == "admin.", "admin", job)) %>% 
  mutate(across(c(marital, job, education, contact, poutcome, day), as.factor)) %>% 
  mutate(across(c(default, housing, loan, y), ~ .x == "yes")) %>% 
  mutate(month = factor(month, levels = c("jan", "feb", "mar", "apr", "may", "jun",
                                          "jul", "aug", "sep", "oct", "nov", "dec")),

         job = relevel(job, ref = "unemployed"),
         marital = relevel(marital, ref = "single"),
         education = relevel(education, ref = "unknown"),
         contact = relevel(contact, ref = "unknown"),
         poutcome = relevel(poutcome, ref = "unknown"))

str(bank_full)
```

We have 45211 rows and 16 columns (excluding y).

A look at the description by the researchers tells us that there are no missing values even though some columns have values "unknown". We have to decide whether to keep them as "unknown" or convert them to NA. Either way, missing values must be inspected.

```{r}
sum(apply(bank_full == "unknown", 1, any))
```

There are a total of 37369 rows with at least one "unknown" value.

How many "unknowns" does each column have?

```{r}
unknown_table <- data.frame(
  unknown_count = sapply(bank_full, function(col) sum(col == "unknown", na.rm = TRUE))) %>% 
  arrange(desc(unknown_count)) %>% 
  filter(unknown_count != 0)

print(unknown_table)
```

Almost all of the poutcome values are unknown. Let's keep this column for now as we will look at outcome distributions with regard to y values later on.

Lastly, since some columns have names that may be difficult to interpret without looking at the metadata first, we should rename them.

```{r}
bank_full <- bank_full %>% 
  rename(in_default = "default",
         housing_loan = "housing",
         personal_loan = "loan",
         contact_type = "contact",
         subscribed = "y")
```

```{r}
lapply(bank_full[ , !(names(bank_full) %in% c("age", "balance", "duration", "pdays"))], unique)
```
Looking at the unique columns values we do not see anything out of the ordinary.

## Exploratory analysis

Now we can look at each variable separately.

### Age

```{r}
ggplot(bank_full, aes(x = age)) +
  geom_bar() + 
  facet_grid(subscribed ~ ., scales = "free_y")
```
The vast majority of clients contacted by the bank were between 26 and 60 years old.

```{r}
bank_full = bank_full %>% 
  mutate(age_categ = case_when(
    age > 60 ~ "high",
    age > 26 ~ "mid",
    TRUE ~ "low"
  ))

CrossTable(bank_full$subscribed, bank_full$age_categ, prop.t = FALSE, prop.chisq = FALSE)
```
Clients of the age 60+ were most likely to subscribe: 42.3% of them chose to do so. That is the highest percentage of all age groups even though older clients make up the smallest part of the total population.

The data does not seem to indicate a linear relationship between age and subscription rates. Either way, we will keep a continuous version of the age variable.

## Job

```{r}
table(bank_full$job)
```
There are a total of 228 unknown values. Due to the large row count we can afford to drop these rows.

```{r}
bank_full <- bank_full %>% filter(job != "unknown")
```

```{r}
nrow(bank_full)
```


## Manipulating data

We select a small random sample of the provided data with a pre-determined seed for repeatable results.

```{r}
set.seed(167)
smallBank <- sample_n(bank_full, 400, replace = FALSE)
```

```{r}
summary(bank_full[, c("age", "job", "marital", "education", "in_default", "housing_loan", "personal_loan", "poutcome")])
```
We notice that practically all values in poutcome are set as unknown and therefore won't be useful during modelling. We can remove that column.

```{r}
#bank_full <- bank_full %>% 
#  select(-poutcome)
```

Let's choose a data frame with the clients that have a dangerously low balance and have or have had a partner at a point in their life. Due to low numbers in the total population, let's search for them in the full data set.

```{r}
lowBalwPartner <- bank_full %>% 
  filter(balance < 100 & marital %in% c("maried", "divorced"))
```

Also, we'll filter another group of clients which have at least one loan with the bank and are at least of the median age for the data set.

```{r}
withLoans <- bank_full %>% 
  filter((housing_loan == TRUE | personal_loan == TRUE) & age >= median(age, na.rm = TRUE))
```

We may also calculate the summarizing statistics.

```{r}
job_summary <- bank_full %>%
  group_by(job) %>%
  summarise(
    age_mean = round(mean(age, na.rm = TRUE), 2),
    balance_mean = mean(balance, na.rm = TRUE),
    balance_median = median(balance, na.rm = TRUE),
    balance_sd = sd(balance, na.rm = TRUE),
    duration_median = median(duration, na.rm = TRUE),
    n = n()
  ) %>%
  arrange(desc(n), desc(age_mean))

print(job_summary)
```

The summarized statistics allows us to make a few insights about the clients that were contacted. First, the clients with a job in management had the highest average balance. Second, high standard deviation tells us that client balance varies quite a lot from one client to another. Third, most clients over all had a balance in the mid-500s. Fourth, most of the contacted clients were blue-collar workers. That is quite normal as blue-collar workers usually make up the largest percentage of the population.

We should also inspect the clients that chose to subscribe to a deposit and what characteristics they show.

```{r}
subscriber_summary <- bank_full %>%
  filter(subscribed == TRUE) %>%
  select(-in_default) %>%
  summarise(across(everything(), ~DescTools::Mode(.x), .names = "mode_{.col}"))

print(subscriber_summary)
```

The data shows us that the "most common" client that chose to subscribe to a deposit is a 32 y.o. married management worker which was contacted via phone in May and the phone call lasted 261 seconds. These could be the key factors which influence the probability of subscription.

Using the previous conclusion, we may create a mock variable that assigns a score of how likely each client is to subscribe to a deposit. In order to give sense to the number representation of the score, we will apply a min-max transformation.

```{r}
find_engagement <- function(duration, balance, housing_loan, personal_loan, in_default) {
  if(in_default != TRUE){
    score <- duration + 10 * (balance / 1000) - housing_loan * 10 - personal_loan * 20
    if (score < 0){
      return(0)
    } else {
      return(score)
    }
  } else {
    return(0)
  }
}

bank_full <- bank_full %>% 
  mutate(engagement_score = mapply(find_engagement, duration, balance, housing_loan, personal_loan, in_default)) %>%
  mutate(engagement_score = round((engagement_score - min(engagement_score, na.rm = TRUE)) / 
           (max(engagement_score, na.rm = TRUE) - min(engagement_score, na.rm = TRUE)), 3))
```

In order to detect clients that have no loans and sufficient balance to make a bank term deposit (a. k. a. are "good" potential depositors), but have specifically chosen not to, we will create a new indicator column.

```{r}
bank_full_potencial <- bank_full %>%
  mutate(potential_client = balance > 1000 & campaign > 0 & previous == 0 &
                            !in_default & !housing_loan & !personal_loan)
summary(bank_full_potencial$potential_client)
```

We can see that to 5227 "potential" clients the marketing campaign hasn't been effective.

We can also take a look at the contacted clients with the highest balance by job type.

```{r}
max_balance_job <- bank_full %>% 
  group_by(job) %>% 
  summarise(max_balance = max(balance))

print(max_balance_job)
```

The client with the highest balance has a job in management.
